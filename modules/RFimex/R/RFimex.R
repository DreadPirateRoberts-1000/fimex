# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -I/usr/include -c++ -r -module RFimex -o RFimex/src/fimex_wrap.cpp fimex.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_mifi_cdm_reader', contains = 'C++Reference')
setClass('_p_MetNoFimex__SliceBuilder', contains = 'C++Reference')
setClass('_p_MetNoFimex__CDM', contains = 'C++Reference')
setClass('_p_MetNoFimex__CDMReader', contains = 'C++Reference')
setClass('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', contains = 'C++Reference')
setClass('_p_MetNoFimex__CDMFileReaderFactory', contains = 'C++Reference')
setClass('_p_MetNoFimex__NetCDF_CDMWriter', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of IntVector___nonzero__

`IntVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector___nonzero__', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`IntVector___nonzero__`, 'returnType') = 'logical'
attr(`IntVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector___nonzero__`) = c("SWIGFunction", class('IntVector___nonzero__'))

# Start of IntVector___len__

`IntVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector___len__', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector___len__`, 'returnType') = 'integer'
attr(`IntVector___len__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector___len__`) = c("SWIGFunction", class('IntVector___len__'))

# Start of IntVector_pop

`IntVector_pop` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_pop', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_pop`, 'returnType') = 'integer'
attr(`IntVector_pop`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_pop`) = c("SWIGFunction", class('IntVector_pop'))

# Start of IntVector___getslice__

`IntVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_IntVector___getslice__', self, i, j, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  ans
  
}

attr(`IntVector___getslice__`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`IntVector___getslice__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', 'integer')
class(`IntVector___getslice__`) = c("SWIGFunction", class('IntVector___getslice__'))

# Start of IntVector___setslice__

`IntVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_IntVector___setslice__', self, i, j, v, PACKAGE='RFimex');
  
}

attr(`IntVector___setslice__`, 'returnType') = 'void'
attr(`IntVector___setslice__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', 'integer', '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector___setslice__`) = c("SWIGFunction", class('IntVector___setslice__'))

# Start of IntVector___delslice__

`IntVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_IntVector___delslice__', self, i, j, PACKAGE='RFimex');
  
}

attr(`IntVector___delslice__`, 'returnType') = 'void'
attr(`IntVector___delslice__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', 'integer')
class(`IntVector___delslice__`) = c("SWIGFunction", class('IntVector___delslice__'))

# Start of IntVector___delitem__

`IntVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_IntVector___delitem__', self, i, PACKAGE='RFimex');
  
}

attr(`IntVector___delitem__`, 'returnType') = 'void'
attr(`IntVector___delitem__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer')
class(`IntVector___delitem__`) = c("SWIGFunction", class('IntVector___delitem__'))

# Start of IntVector___getitem__

`IntVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_IntVector___getitem__', self, i, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector___getitem__`, 'returnType') = '_p_size_t'
attr(`IntVector___getitem__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer')
class(`IntVector___getitem__`) = c("SWIGFunction", class('IntVector___getitem__'))

# Start of IntVector___setitem__

`IntVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_IntVector___setitem__', self, i, x, PACKAGE='RFimex');
  
}

attr(`IntVector___setitem__`, 'returnType') = 'void'
attr(`IntVector___setitem__`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', '_p_size_t')
class(`IntVector___setitem__`) = c("SWIGFunction", class('IntVector___setitem__'))

# Start of IntVector_append

`IntVector_append` = function(self, x)
{
  ;.Call('R_swig_IntVector_append', self, x, PACKAGE='RFimex');
  
}

attr(`IntVector_append`, 'returnType') = 'void'
attr(`IntVector_append`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', '_p_size_t')
class(`IntVector_append`) = c("SWIGFunction", class('IntVector_append'))

# Start of new_IntVector

`IntVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_IntVector__SWIG_0', PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_0`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
class(`IntVector__SWIG_0`) = c("SWIGFunction", class('IntVector__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_IntVector__SWIG_1', s_arg1, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_1`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`IntVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector__SWIG_1`) = c("SWIGFunction", class('IntVector__SWIG_1'))

# Start of IntVector_empty

`IntVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_IntVector_empty', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`IntVector_empty`, 'returnType') = 'logical'
attr(`IntVector_empty`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_empty`) = c("SWIGFunction", class('IntVector_empty'))

# Start of IntVector_size

`IntVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_size', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_size`, 'returnType') = 'integer'
attr(`IntVector_size`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_size`) = c("SWIGFunction", class('IntVector_size'))

# Start of IntVector_clear

`IntVector_clear` = function(self)
{
  ;.Call('R_swig_IntVector_clear', self, PACKAGE='RFimex');
  
}

attr(`IntVector_clear`, 'returnType') = 'void'
attr(`IntVector_clear`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_clear`) = c("SWIGFunction", class('IntVector_clear'))

# Start of IntVector_swap

`IntVector_swap` = function(self, v)
{
  ;.Call('R_swig_IntVector_swap', self, v, PACKAGE='RFimex');
  
}

attr(`IntVector_swap`, 'returnType') = 'void'
attr(`IntVector_swap`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_swap`) = c("SWIGFunction", class('IntVector_swap'))

# Start of IntVector_get_allocator

`IntVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_get_allocator', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__allocatorT_size_t_t";
  
  ans
  
}

attr(`IntVector_get_allocator`, 'returnType') = '_p_std__allocatorT_size_t_t'
attr(`IntVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_get_allocator`) = c("SWIGFunction", class('IntVector_get_allocator'))

# Start of new_IntVector

`IntVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_IntVector__SWIG_2', size, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_2`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`IntVector__SWIG_2`, "inputTypes") = c('integer')
class(`IntVector__SWIG_2`) = c("SWIGFunction", class('IntVector__SWIG_2'))

# Start of IntVector_pop_back

`IntVector_pop_back` = function(self)
{
  ;.Call('R_swig_IntVector_pop_back', self, PACKAGE='RFimex');
  
}

attr(`IntVector_pop_back`, 'returnType') = 'void'
attr(`IntVector_pop_back`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_pop_back`) = c("SWIGFunction", class('IntVector_pop_back'))

# Start of IntVector_resize

`IntVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_IntVector_resize__SWIG_0', self, new_size, PACKAGE='RFimex');
  
}

attr(`IntVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer')
class(`IntVector_resize__SWIG_0`) = c("SWIGFunction", class('IntVector_resize__SWIG_0'))

# Start of new_IntVector

`IntVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_IntVector__SWIG_3', size, value, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  reg.finalizer(ans, delete_IntVector)
  ans
  
}

attr(`IntVector__SWIG_3`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`IntVector__SWIG_3`, "inputTypes") = c('integer', '_p_size_t')
class(`IntVector__SWIG_3`) = c("SWIGFunction", class('IntVector__SWIG_3'))

`IntVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- IntVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- IntVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')) {
      f <- IntVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && extends(argtypes[2], '_p_size_t')) {
      f <- IntVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for IntVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_push_back

`IntVector_push_back` = function(self, x)
{
  ;.Call('R_swig_IntVector_push_back', self, x, PACKAGE='RFimex');
  
}

attr(`IntVector_push_back`, 'returnType') = 'void'
attr(`IntVector_push_back`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', '_p_size_t')
class(`IntVector_push_back`) = c("SWIGFunction", class('IntVector_push_back'))

# Start of IntVector_front

`IntVector_front` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_front', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_front`, 'returnType') = '_p_size_t'
attr(`IntVector_front`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_front`) = c("SWIGFunction", class('IntVector_front'))

# Start of IntVector_back

`IntVector_back` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_back', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_back`, 'returnType') = '_p_size_t'
attr(`IntVector_back`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_back`) = c("SWIGFunction", class('IntVector_back'))

# Start of IntVector_assign

`IntVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_IntVector_assign', self, n, x, PACKAGE='RFimex');
  
}

attr(`IntVector_assign`, 'returnType') = 'void'
attr(`IntVector_assign`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', '_p_size_t')
class(`IntVector_assign`) = c("SWIGFunction", class('IntVector_assign'))

# Start of IntVector_resize

`IntVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_IntVector_resize__SWIG_1', self, new_size, x, PACKAGE='RFimex');
  
}

attr(`IntVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`IntVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer', '_p_size_t')
class(`IntVector_resize__SWIG_1`) = c("SWIGFunction", class('IntVector_resize__SWIG_1'))

`IntVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- IntVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && extends(argtypes[3], '_p_size_t')) {
      f <- IntVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for IntVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of IntVector_reserve

`IntVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_IntVector_reserve', self, n, PACKAGE='RFimex');
  
}

attr(`IntVector_reserve`, 'returnType') = 'void'
attr(`IntVector_reserve`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', 'integer')
class(`IntVector_reserve`) = c("SWIGFunction", class('IntVector_reserve'))

# Start of IntVector_capacity

`IntVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_IntVector_capacity', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`IntVector_capacity`, 'returnType') = 'integer'
attr(`IntVector_capacity`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`IntVector_capacity`) = c("SWIGFunction", class('IntVector_capacity'))

# Start of delete_IntVector

`delete_IntVector` = function(self)
{
  ;.Call('R_swig_delete_IntVector', self, PACKAGE='RFimex');
  
}

attr(`delete_IntVector`, 'returnType') = 'void'
attr(`delete_IntVector`, "inputTypes") = c('_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`delete_IntVector`) = c("SWIGFunction", class('delete_IntVector'))

# Start of accessor method for std::vector<(size_t)>
setMethod('$', '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = IntVector___nonzero__, '__len__' = IntVector___len__, 'pop' = IntVector_pop, '__getslice__' = IntVector___getslice__, '__setslice__' = IntVector___setslice__, '__delslice__' = IntVector___delslice__, '__delitem__' = IntVector___delitem__, '__getitem__' = IntVector___getitem__, '__setitem__' = IntVector___setitem__, 'append' = IntVector_append, 'empty' = IntVector_empty, 'size' = IntVector_size, 'clear' = IntVector_clear, 'swap' = IntVector_swap, 'get_allocator' = IntVector_get_allocator, 'pop_back' = IntVector_pop_back, 'resize' = IntVector_resize, 'push_back' = IntVector_push_back, 'front' = IntVector_front, 'back' = IntVector_back, 'assign' = IntVector_assign, 'reserve' = IntVector_reserve, 'capacity' = IntVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(size_t)>
setMethod('delete', '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t', function(obj) {delete_std__vectorT_size_t_std__allocatorT_size_t_t_t(obj)})
# Start of DoubleVector___nonzero__

`DoubleVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector___nonzero__', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector___nonzero__`, 'returnType') = 'logical'
attr(`DoubleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___nonzero__`) = c("SWIGFunction", class('DoubleVector___nonzero__'))

# Start of DoubleVector___len__

`DoubleVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector___len__', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector___len__`, 'returnType') = 'integer'
attr(`DoubleVector___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___len__`) = c("SWIGFunction", class('DoubleVector___len__'))

# Start of DoubleVector_pop

`DoubleVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_pop', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector_pop`, 'returnType') = 'numeric'
attr(`DoubleVector_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop`) = c("SWIGFunction", class('DoubleVector_pop'))

# Start of DoubleVector___getslice__

`DoubleVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_DoubleVector___getslice__', self, i, j, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`DoubleVector___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___getslice__`) = c("SWIGFunction", class('DoubleVector___getslice__'))

# Start of DoubleVector___setslice__

`DoubleVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DoubleVector___setslice__', self, i, j, v, PACKAGE='RFimex');
  
}

attr(`DoubleVector___setslice__`, 'returnType') = 'void'
attr(`DoubleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___setslice__`) = c("SWIGFunction", class('DoubleVector___setslice__'))

# Start of DoubleVector___delslice__

`DoubleVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___delslice__', self, i, j, PACKAGE='RFimex');
  
}

attr(`DoubleVector___delslice__`, 'returnType') = 'void'
attr(`DoubleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___delslice__`) = c("SWIGFunction", class('DoubleVector___delslice__'))

# Start of DoubleVector___delitem__

`DoubleVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___delitem__', self, i, PACKAGE='RFimex');
  
}

attr(`DoubleVector___delitem__`, 'returnType') = 'void'
attr(`DoubleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___delitem__`) = c("SWIGFunction", class('DoubleVector___delitem__'))

# Start of DoubleVector___getitem__

`DoubleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___getitem__', self, i, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector___getitem__`, 'returnType') = 'numeric'
attr(`DoubleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___getitem__`) = c("SWIGFunction", class('DoubleVector___getitem__'))

# Start of DoubleVector___setitem__

`DoubleVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DoubleVector___setitem__', self, i, x, PACKAGE='RFimex');
  
}

attr(`DoubleVector___setitem__`, 'returnType') = 'void'
attr(`DoubleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector___setitem__`) = c("SWIGFunction", class('DoubleVector___setitem__'))

# Start of DoubleVector_append

`DoubleVector_append` = function(self, x)
{
  ;.Call('R_swig_DoubleVector_append', self, x, PACKAGE='RFimex');
  
}

attr(`DoubleVector_append`, 'returnType') = 'void'
attr(`DoubleVector_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_append`) = c("SWIGFunction", class('DoubleVector_append'))

# Start of new_DoubleVector

`DoubleVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_0', PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`DoubleVector__SWIG_0`) = c("SWIGFunction", class('DoubleVector__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_1', s_arg1, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector__SWIG_1`) = c("SWIGFunction", class('DoubleVector__SWIG_1'))

# Start of DoubleVector_empty

`DoubleVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_empty', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector_empty`, 'returnType') = 'logical'
attr(`DoubleVector_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_empty`) = c("SWIGFunction", class('DoubleVector_empty'))

# Start of DoubleVector_size

`DoubleVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_size', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector_size`, 'returnType') = 'integer'
attr(`DoubleVector_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_size`) = c("SWIGFunction", class('DoubleVector_size'))

# Start of DoubleVector_clear

`DoubleVector_clear` = function(self)
{
  ;.Call('R_swig_DoubleVector_clear', self, PACKAGE='RFimex');
  
}

attr(`DoubleVector_clear`, 'returnType') = 'void'
attr(`DoubleVector_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_clear`) = c("SWIGFunction", class('DoubleVector_clear'))

# Start of DoubleVector_swap

`DoubleVector_swap` = function(self, v)
{
  ;.Call('R_swig_DoubleVector_swap', self, v, PACKAGE='RFimex');
  
}

attr(`DoubleVector_swap`, 'returnType') = 'void'
attr(`DoubleVector_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_swap`) = c("SWIGFunction", class('DoubleVector_swap'))

# Start of DoubleVector_get_allocator

`DoubleVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_get_allocator', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__allocatorT_double_t";
  
  ans
  
}

attr(`DoubleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`DoubleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_get_allocator`) = c("SWIGFunction", class('DoubleVector_get_allocator'))

# Start of new_DoubleVector

`DoubleVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_2', size, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_2`, "inputTypes") = c('integer')
class(`DoubleVector__SWIG_2`) = c("SWIGFunction", class('DoubleVector__SWIG_2'))

# Start of DoubleVector_pop_back

`DoubleVector_pop_back` = function(self)
{
  ;.Call('R_swig_DoubleVector_pop_back', self, PACKAGE='RFimex');
  
}

attr(`DoubleVector_pop_back`, 'returnType') = 'void'
attr(`DoubleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop_back`) = c("SWIGFunction", class('DoubleVector_pop_back'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_0', self, new_size, PACKAGE='RFimex');
  
}

attr(`DoubleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_resize__SWIG_0`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;ans = .Call('R_swig_new_DoubleVector__SWIG_3', size, value, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  reg.finalizer(ans, delete_DoubleVector)
  ans
  
}

attr(`DoubleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`DoubleVector__SWIG_3`) = c("SWIGFunction", class('DoubleVector__SWIG_3'))

`DoubleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DoubleVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- DoubleVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t')) {
      f <- DoubleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.numeric(argv[[2]])) {
      f <- DoubleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_push_back

`DoubleVector_push_back` = function(self, x)
{
  ;.Call('R_swig_DoubleVector_push_back', self, x, PACKAGE='RFimex');
  
}

attr(`DoubleVector_push_back`, 'returnType') = 'void'
attr(`DoubleVector_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_push_back`) = c("SWIGFunction", class('DoubleVector_push_back'))

# Start of DoubleVector_front

`DoubleVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_front', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector_front`, 'returnType') = 'numeric'
attr(`DoubleVector_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_front`) = c("SWIGFunction", class('DoubleVector_front'))

# Start of DoubleVector_back

`DoubleVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_DoubleVector_back', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`DoubleVector_back`, 'returnType') = 'numeric'
attr(`DoubleVector_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_back`) = c("SWIGFunction", class('DoubleVector_back'))

# Start of DoubleVector_assign

`DoubleVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DoubleVector_assign', self, n, x, PACKAGE='RFimex');
  
}

attr(`DoubleVector_assign`, 'returnType') = 'void'
attr(`DoubleVector_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_assign`) = c("SWIGFunction", class('DoubleVector_assign'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_1', self, new_size, x, PACKAGE='RFimex');
  
}

attr(`DoubleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_resize__SWIG_1`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_1'))

`DoubleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- DoubleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.numeric(argv[[3]])) {
      f <- DoubleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_reserve

`DoubleVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DoubleVector_reserve', self, n, PACKAGE='RFimex');
  
}

attr(`DoubleVector_reserve`, 'returnType') = 'void'
attr(`DoubleVector_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_reserve`) = c("SWIGFunction", class('DoubleVector_reserve'))

# Start of DoubleVector_capacity

`DoubleVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_DoubleVector_capacity', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`DoubleVector_capacity`, 'returnType') = 'integer'
attr(`DoubleVector_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_capacity`) = c("SWIGFunction", class('DoubleVector_capacity'))

# Start of delete_DoubleVector

`delete_DoubleVector` = function(self)
{
  ;.Call('R_swig_delete_DoubleVector', self, PACKAGE='RFimex');
  
}

attr(`delete_DoubleVector`, 'returnType') = 'void'
attr(`delete_DoubleVector`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_DoubleVector`) = c("SWIGFunction", class('delete_DoubleVector'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DoubleVector___nonzero__, '__len__' = DoubleVector___len__, 'pop' = DoubleVector_pop, '__getslice__' = DoubleVector___getslice__, '__setslice__' = DoubleVector___setslice__, '__delslice__' = DoubleVector___delslice__, '__delitem__' = DoubleVector___delitem__, '__getitem__' = DoubleVector___getitem__, '__setitem__' = DoubleVector___setitem__, 'append' = DoubleVector_append, 'empty' = DoubleVector_empty, 'size' = DoubleVector_size, 'clear' = DoubleVector_clear, 'swap' = DoubleVector_swap, 'get_allocator' = DoubleVector_get_allocator, 'pop_back' = DoubleVector_pop_back, 'resize' = DoubleVector_resize, 'push_back' = DoubleVector_push_back, 'front' = DoubleVector_front, 'back' = DoubleVector_back, 'assign' = DoubleVector_assign, 'reserve' = DoubleVector_reserve, 'capacity' = DoubleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of StringVector___nonzero__

`StringVector___nonzero__` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StringVector___nonzero__', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector___nonzero__`, 'returnType') = 'logical'
attr(`StringVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___nonzero__`) = c("SWIGFunction", class('StringVector___nonzero__'))

# Start of StringVector___len__

`StringVector___len__` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StringVector___len__', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StringVector___len__`, 'returnType') = 'integer'
attr(`StringVector___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___len__`) = c("SWIGFunction", class('StringVector___len__'))

# Start of StringVector_pop

`StringVector_pop` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StringVector_pop', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector_pop`, 'returnType') = 'character'
attr(`StringVector_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop`) = c("SWIGFunction", class('StringVector_pop'))

# Start of StringVector___getslice__

`StringVector___getslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StringVector___getslice__', self, i, j, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  ans
  
}

attr(`StringVector___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___getslice__`) = c("SWIGFunction", class('StringVector___getslice__'))

# Start of StringVector___setslice__

`StringVector___setslice__` = function(self, i, j, v)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_StringVector___setslice__', self, i, j, v, PACKAGE='RFimex');
  
}

attr(`StringVector___setslice__`, 'returnType') = 'void'
attr(`StringVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___setslice__`) = c("SWIGFunction", class('StringVector___setslice__'))

# Start of StringVector___delslice__

`StringVector___delslice__` = function(self, i, j)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StringVector___delslice__', self, i, j, PACKAGE='RFimex');
  
}

attr(`StringVector___delslice__`, 'returnType') = 'void'
attr(`StringVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___delslice__`) = c("SWIGFunction", class('StringVector___delslice__'))

# Start of StringVector___delitem__

`StringVector___delitem__` = function(self, i)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___delitem__', self, i, PACKAGE='RFimex');
  
}

attr(`StringVector___delitem__`, 'returnType') = 'void'
attr(`StringVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___delitem__`) = c("SWIGFunction", class('StringVector___delitem__'))

# Start of StringVector___getitem__

`StringVector___getitem__` = function(self, i, .copy = FALSE)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___getitem__', self, i, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector___getitem__`, 'returnType') = 'character'
attr(`StringVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___getitem__`) = c("SWIGFunction", class('StringVector___getitem__'))

# Start of StringVector___setitem__

`StringVector___setitem__` = function(self, i, x)
{
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector___setitem__', self, i, x, PACKAGE='RFimex');
  
}

attr(`StringVector___setitem__`, 'returnType') = 'void'
attr(`StringVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector___setitem__`) = c("SWIGFunction", class('StringVector___setitem__'))

# Start of StringVector_append

`StringVector_append` = function(self, x)
{
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_append', self, x, PACKAGE='RFimex');
  
}

attr(`StringVector_append`, 'returnType') = 'void'
attr(`StringVector_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_append`) = c("SWIGFunction", class('StringVector_append'))

# Start of new_StringVector

`StringVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StringVector__SWIG_0', PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`StringVector__SWIG_0`) = c("SWIGFunction", class('StringVector__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_1` = function(s_arg1)
{
  ;ans = .Call('R_swig_new_StringVector__SWIG_1', s_arg1, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector__SWIG_1`) = c("SWIGFunction", class('StringVector__SWIG_1'))

# Start of StringVector_empty

`StringVector_empty` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StringVector_empty', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector_empty`, 'returnType') = 'logical'
attr(`StringVector_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_empty`) = c("SWIGFunction", class('StringVector_empty'))

# Start of StringVector_size

`StringVector_size` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StringVector_size', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StringVector_size`, 'returnType') = 'integer'
attr(`StringVector_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_size`) = c("SWIGFunction", class('StringVector_size'))

# Start of StringVector_clear

`StringVector_clear` = function(self)
{
  ;.Call('R_swig_StringVector_clear', self, PACKAGE='RFimex');
  
}

attr(`StringVector_clear`, 'returnType') = 'void'
attr(`StringVector_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_clear`) = c("SWIGFunction", class('StringVector_clear'))

# Start of StringVector_swap

`StringVector_swap` = function(self, v)
{
  ;.Call('R_swig_StringVector_swap', self, v, PACKAGE='RFimex');
  
}

attr(`StringVector_swap`, 'returnType') = 'void'
attr(`StringVector_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_swap`) = c("SWIGFunction", class('StringVector_swap'))

# Start of StringVector_get_allocator

`StringVector_get_allocator` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StringVector_get_allocator', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__allocatorT_std__string_t";
  
  ans
  
}

attr(`StringVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`StringVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_get_allocator`) = c("SWIGFunction", class('StringVector_get_allocator'))

# Start of new_StringVector

`StringVector__SWIG_2` = function(size)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StringVector__SWIG_2', size, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_2`, "inputTypes") = c('integer')
class(`StringVector__SWIG_2`) = c("SWIGFunction", class('StringVector__SWIG_2'))

# Start of StringVector_pop_back

`StringVector_pop_back` = function(self)
{
  ;.Call('R_swig_StringVector_pop_back', self, PACKAGE='RFimex');
  
}

attr(`StringVector_pop_back`, 'returnType') = 'void'
attr(`StringVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop_back`) = c("SWIGFunction", class('StringVector_pop_back'))

# Start of StringVector_resize

`StringVector_resize__SWIG_0` = function(self, new_size)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StringVector_resize__SWIG_0', self, new_size, PACKAGE='RFimex');
  
}

attr(`StringVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_resize__SWIG_0`) = c("SWIGFunction", class('StringVector_resize__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_3` = function(size, value)
{
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_StringVector__SWIG_3', size, value, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  reg.finalizer(ans, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`StringVector__SWIG_3`) = c("SWIGFunction", class('StringVector__SWIG_3'))

`StringVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StringVector__SWIG_0; 
  } else if (argc == 1) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]]))) {
      f <- StringVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')) {
      f <- StringVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if ((is.integer(argv[[1]]) || is.numeric(argv[[1]])) && is.character(argv[[2]])) {
      f <- StringVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StringVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_push_back

`StringVector_push_back` = function(self, x)
{
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_push_back', self, x, PACKAGE='RFimex');
  
}

attr(`StringVector_push_back`, 'returnType') = 'void'
attr(`StringVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_push_back`) = c("SWIGFunction", class('StringVector_push_back'))

# Start of StringVector_front

`StringVector_front` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StringVector_front', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector_front`, 'returnType') = 'character'
attr(`StringVector_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_front`) = c("SWIGFunction", class('StringVector_front'))

# Start of StringVector_back

`StringVector_back` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_StringVector_back', self, as.logical(.copy), PACKAGE='RFimex');
  
}

attr(`StringVector_back`, 'returnType') = 'character'
attr(`StringVector_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_back`) = c("SWIGFunction", class('StringVector_back'))

# Start of StringVector_assign

`StringVector_assign` = function(self, n, x)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_assign', self, n, x, PACKAGE='RFimex');
  
}

attr(`StringVector_assign`, 'returnType') = 'void'
attr(`StringVector_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_assign`) = c("SWIGFunction", class('StringVector_assign'))

# Start of StringVector_resize

`StringVector_resize__SWIG_1` = function(self, new_size, x)
{
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_resize__SWIG_1', self, new_size, x, PACKAGE='RFimex');
  
}

attr(`StringVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_resize__SWIG_1`) = c("SWIGFunction", class('StringVector_resize__SWIG_1'))

`StringVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]]))) {
      f <- StringVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && is.character(argv[[3]])) {
      f <- StringVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StringVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_reserve

`StringVector_reserve` = function(self, n)
{
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StringVector_reserve', self, n, PACKAGE='RFimex');
  
}

attr(`StringVector_reserve`, 'returnType') = 'void'
attr(`StringVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_reserve`) = c("SWIGFunction", class('StringVector_reserve'))

# Start of StringVector_capacity

`StringVector_capacity` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_StringVector_capacity', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`StringVector_capacity`, 'returnType') = 'integer'
attr(`StringVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_capacity`) = c("SWIGFunction", class('StringVector_capacity'))

# Start of delete_StringVector

`delete_StringVector` = function(self)
{
  ;.Call('R_swig_delete_StringVector', self, PACKAGE='RFimex');
  
}

attr(`delete_StringVector`, 'returnType') = 'void'
attr(`delete_StringVector`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_StringVector`) = c("SWIGFunction", class('delete_StringVector'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StringVector___nonzero__, '__len__' = StringVector___len__, 'pop' = StringVector_pop, '__getslice__' = StringVector___getslice__, '__setslice__' = StringVector___setslice__, '__delslice__' = StringVector___delslice__, '__delitem__' = StringVector___delitem__, '__getitem__' = StringVector___getitem__, '__setitem__' = StringVector___setitem__, 'append' = StringVector_append, 'empty' = StringVector_empty, 'size' = StringVector_size, 'clear' = StringVector_clear, 'swap' = StringVector_swap, 'get_allocator' = StringVector_get_allocator, 'pop_back' = StringVector_pop_back, 'resize' = StringVector_resize, 'push_back' = StringVector_push_back, 'front' = StringVector_front, 'back' = StringVector_back, 'assign' = StringVector_assign, 'reserve' = StringVector_reserve, 'capacity' = StringVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of new_mifi_cdm_reader

`mifi_cdm_reader` = function(reader)
{
  ;ans = .Call('R_swig_new_mifi_cdm_reader', reader, PACKAGE='RFimex');
  class(ans) <- "_p_mifi_cdm_reader";
  
  reg.finalizer(ans, delete_mifi_cdm_reader)
  ans
  
}

attr(`mifi_cdm_reader`, 'returnType') = '_p_mifi_cdm_reader'
attr(`mifi_cdm_reader`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t')
class(`mifi_cdm_reader`) = c("SWIGFunction", class('mifi_cdm_reader'))

# Start of mifi_cdm_reader_get

`mifi_cdm_reader_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_mifi_cdm_reader_get', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_boost__shared_ptrT_MetNoFimex__CDMReader_t";
  
  ans
  
}

attr(`mifi_cdm_reader_get`, 'returnType') = '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t'
attr(`mifi_cdm_reader_get`, "inputTypes") = c('_p_mifi_cdm_reader')
class(`mifi_cdm_reader_get`) = c("SWIGFunction", class('mifi_cdm_reader_get'))

# Start of delete_mifi_cdm_reader

`delete_mifi_cdm_reader` = function(self)
{
  ;.Call('R_swig_delete_mifi_cdm_reader', self, PACKAGE='RFimex');
  
}

attr(`delete_mifi_cdm_reader`, 'returnType') = 'void'
attr(`delete_mifi_cdm_reader`, "inputTypes") = c('_p_mifi_cdm_reader')
class(`delete_mifi_cdm_reader`) = c("SWIGFunction", class('delete_mifi_cdm_reader'))

# Start of accessor method for mifi_cdm_reader
setMethod('$', '_p_mifi_cdm_reader', function(x, name)

{
  accessorFuns = list('get' = mifi_cdm_reader_get);
  vaccessors = c('get');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for mifi_cdm_reader
setMethod('delete', '_p_mifi_cdm_reader', function(obj) {delete_mifi_cdm_reader(obj)})
# Start of mifi_get_variable_number

`mifi_get_variable_number` = function(reader, .copy = FALSE)
{
  ;ans = .Call('R_swig_mifi_get_variable_number', reader, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_size_t";
  
  ans
  
}

attr(`mifi_get_variable_number`, 'returnType') = 'integer'
attr(`mifi_get_variable_number`, "inputTypes") = c('_p_mifi_cdm_reader')
class(`mifi_get_variable_number`) = c("SWIGFunction", class('mifi_get_variable_number'))

# Start of mifi_get_variable_name

`mifi_get_variable_name` = function(reader, pos)
{
  if(length(pos) > 1) {
    warning("using only the first element of pos");
  };
  
  ;.Call('R_swig_mifi_get_variable_name', reader, pos, PACKAGE='RFimex');
  
}

attr(`mifi_get_variable_name`, 'returnType') = 'character'
attr(`mifi_get_variable_name`, "inputTypes") = c('_p_mifi_cdm_reader', 'integer')
class(`mifi_get_variable_name`) = c("SWIGFunction", class('mifi_get_variable_name'))

# Start of new_SliceBuilder

`SliceBuilder__SWIG_0` = function(cdm, varName)
{
  varName = as(varName, "character"); 
  ;ans = .Call('R_swig_new_SliceBuilder__SWIG_0', cdm, varName, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__SliceBuilder";
  
  reg.finalizer(ans, delete_SliceBuilder)
  ans
  
}

attr(`SliceBuilder__SWIG_0`, 'returnType') = '_p_MetNoFimex__SliceBuilder'
attr(`SliceBuilder__SWIG_0`, "inputTypes") = c('_p_MetNoFimex__CDM', 'character')
class(`SliceBuilder__SWIG_0`) = c("SWIGFunction", class('SliceBuilder__SWIG_0'))

# Start of new_SliceBuilder

`SliceBuilder__SWIG_1` = function(dimNames, dimSize)
{
  ;ans = .Call('R_swig_new_SliceBuilder__SWIG_1', dimNames, dimSize, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__SliceBuilder";
  
  reg.finalizer(ans, delete_SliceBuilder)
  ans
  
}

attr(`SliceBuilder__SWIG_1`, 'returnType') = '_p_MetNoFimex__SliceBuilder'
attr(`SliceBuilder__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')
class(`SliceBuilder__SWIG_1`) = c("SWIGFunction", class('SliceBuilder__SWIG_1'))

`SliceBuilder` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_MetNoFimex__CDM') && is.character(argv[[2]])) {
      f <- SliceBuilder__SWIG_0; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && extends(argtypes[2], '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t')) {
      f <- SliceBuilder__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for SliceBuilder with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_SliceBuilder

`delete_SliceBuilder` = function(self)
{
  ;.Call('R_swig_delete_SliceBuilder', self, PACKAGE='RFimex');
  
}

attr(`delete_SliceBuilder`, 'returnType') = 'void'
attr(`delete_SliceBuilder`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`delete_SliceBuilder`) = c("SWIGFunction", class('delete_SliceBuilder'))

# Start of SliceBuilder_setStartAndSize

`SliceBuilder_setStartAndSize__SWIG_0` = function(self, dimName, start, size)
{
  dimName = as(dimName, "character"); 
  
  
  if(length(start) > 1) {
    warning("using only the first element of start");
  };
  
  
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_SliceBuilder_setStartAndSize__SWIG_0', self, dimName, start, size, PACKAGE='RFimex');
  
}

attr(`SliceBuilder_setStartAndSize__SWIG_0`, 'returnType') = 'void'
attr(`SliceBuilder_setStartAndSize__SWIG_0`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder', 'character', 'integer', 'integer')
class(`SliceBuilder_setStartAndSize__SWIG_0`) = c("SWIGFunction", class('SliceBuilder_setStartAndSize__SWIG_0'))

# Start of SliceBuilder_setStartAndSize

`SliceBuilder_setStartAndSize__SWIG_1` = function(self, axis, start, size)
{
  if(length(start) > 1) {
    warning("using only the first element of start");
  };
  
  
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_SliceBuilder_setStartAndSize__SWIG_1', self, axis, start, size, PACKAGE='RFimex');
  
}

attr(`SliceBuilder_setStartAndSize__SWIG_1`, 'returnType') = 'void'
attr(`SliceBuilder_setStartAndSize__SWIG_1`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder', '_p_boost__shared_ptrT_MetNoFimex__CoordinateAxis_const_t', 'integer', 'integer')
class(`SliceBuilder_setStartAndSize__SWIG_1`) = c("SWIGFunction", class('SliceBuilder_setStartAndSize__SWIG_1'))

`SliceBuilder_setStartAndSize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_MetNoFimex__SliceBuilder') && extends(argtypes[2], '_p_boost__shared_ptrT_MetNoFimex__CoordinateAxis_const_t') && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && (is.integer(argv[[4]]) || is.numeric(argv[[4]]))) {
      f <- SliceBuilder_setStartAndSize__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_MetNoFimex__SliceBuilder') && is.character(argv[[2]]) && (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && (is.integer(argv[[4]]) || is.numeric(argv[[4]]))) {
      f <- SliceBuilder_setStartAndSize__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SliceBuilder_setStartAndSize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SliceBuilder_setAll

`SliceBuilder_setAll__SWIG_0` = function(self, dimName)
{
  dimName = as(dimName, "character"); 
  ;.Call('R_swig_SliceBuilder_setAll__SWIG_0', self, dimName, PACKAGE='RFimex');
  
}

attr(`SliceBuilder_setAll__SWIG_0`, 'returnType') = 'void'
attr(`SliceBuilder_setAll__SWIG_0`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder', 'character')
class(`SliceBuilder_setAll__SWIG_0`) = c("SWIGFunction", class('SliceBuilder_setAll__SWIG_0'))

# Start of SliceBuilder_setAll

`SliceBuilder_setAll__SWIG_1` = function(self, axis)
{
  ;.Call('R_swig_SliceBuilder_setAll__SWIG_1', self, axis, PACKAGE='RFimex');
  
}

attr(`SliceBuilder_setAll__SWIG_1`, 'returnType') = 'void'
attr(`SliceBuilder_setAll__SWIG_1`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder', '_p_boost__shared_ptrT_MetNoFimex__CoordinateAxis_const_t')
class(`SliceBuilder_setAll__SWIG_1`) = c("SWIGFunction", class('SliceBuilder_setAll__SWIG_1'))

`SliceBuilder_setAll` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_MetNoFimex__SliceBuilder') && extends(argtypes[2], '_p_boost__shared_ptrT_MetNoFimex__CoordinateAxis_const_t')) {
      f <- SliceBuilder_setAll__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_MetNoFimex__SliceBuilder') && is.character(argv[[2]])) {
      f <- SliceBuilder_setAll__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for SliceBuilder_setAll with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of SliceBuilder_getDimensionStartPositions

`SliceBuilder_getDimensionStartPositions` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SliceBuilder_getDimensionStartPositions', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  ans
  
}

attr(`SliceBuilder_getDimensionStartPositions`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`SliceBuilder_getDimensionStartPositions`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`SliceBuilder_getDimensionStartPositions`) = c("SWIGFunction", class('SliceBuilder_getDimensionStartPositions'))

# Start of SliceBuilder_getDimensionSizes

`SliceBuilder_getDimensionSizes` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SliceBuilder_getDimensionSizes', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  ans
  
}

attr(`SliceBuilder_getDimensionSizes`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`SliceBuilder_getDimensionSizes`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`SliceBuilder_getDimensionSizes`) = c("SWIGFunction", class('SliceBuilder_getDimensionSizes'))

# Start of SliceBuilder_getDimensionNames

`SliceBuilder_getDimensionNames` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SliceBuilder_getDimensionNames', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  ans
  
}

attr(`SliceBuilder_getDimensionNames`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`SliceBuilder_getDimensionNames`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`SliceBuilder_getDimensionNames`) = c("SWIGFunction", class('SliceBuilder_getDimensionNames'))

# Start of SliceBuilder_getUnsetDimensionNames

`SliceBuilder_getUnsetDimensionNames` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SliceBuilder_getUnsetDimensionNames', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_std__string_std__allocatorT_std__string_t_t";
  
  ans
  
}

attr(`SliceBuilder_getUnsetDimensionNames`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`SliceBuilder_getUnsetDimensionNames`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`SliceBuilder_getUnsetDimensionNames`) = c("SWIGFunction", class('SliceBuilder_getUnsetDimensionNames'))

# Start of SliceBuilder_getMaxDimensionSizes

`SliceBuilder_getMaxDimensionSizes` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_SliceBuilder_getMaxDimensionSizes', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_size_t_std__allocatorT_size_t_t_t";
  
  ans
  
}

attr(`SliceBuilder_getMaxDimensionSizes`, 'returnType') = '_p_std__vectorT_size_t_std__allocatorT_size_t_t_t'
attr(`SliceBuilder_getMaxDimensionSizes`, "inputTypes") = c('_p_MetNoFimex__SliceBuilder')
class(`SliceBuilder_getMaxDimensionSizes`) = c("SWIGFunction", class('SliceBuilder_getMaxDimensionSizes'))

# Start of accessor method for MetNoFimex::SliceBuilder
setMethod('$', '_p_MetNoFimex__SliceBuilder', function(x, name)

{
  accessorFuns = list('setStartAndSize' = SliceBuilder_setStartAndSize, 'setAll' = SliceBuilder_setAll, 'getDimensionStartPositions' = SliceBuilder_getDimensionStartPositions, 'getDimensionSizes' = SliceBuilder_getDimensionSizes, 'getDimensionNames' = SliceBuilder_getDimensionNames, 'getUnsetDimensionNames' = SliceBuilder_getUnsetDimensionNames, 'getMaxDimensionSizes' = SliceBuilder_getMaxDimensionSizes);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MetNoFimex::SliceBuilder
setMethod('delete', '_p_MetNoFimex__SliceBuilder', function(obj) {delete_MetNoFimex__SliceBuilder(obj)})
# Start of delete_CDM

`delete_CDM` = function(self)
{
  ;.Call('R_swig_delete_CDM', self, PACKAGE='RFimex');
  
}

attr(`delete_CDM`, 'returnType') = 'void'
attr(`delete_CDM`, "inputTypes") = c('_p_MetNoFimex__CDM')
class(`delete_CDM`) = c("SWIGFunction", class('delete_CDM'))

setMethod('delete', '_p_MetNoFimex__CDM', function(obj) {delete_MetNoFimex__CDM(obj)})
# Start of CDMReader_getCDM

`CDMReader_getCDM` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_CDMReader_getCDM', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__CDM";
  
  ans
  
}

attr(`CDMReader_getCDM`, 'returnType') = '_p_MetNoFimex__CDM'
attr(`CDMReader_getCDM`, "inputTypes") = c('_p_MetNoFimex__CDMReader')
class(`CDMReader_getCDM`) = c("SWIGFunction", class('CDMReader_getCDM'))

# Start of CDMReader_getSliceVecInUnit

`CDMReader_getSliceVecInUnit__SWIG_0` = function(self, varName, sb, units)
{
  varName = as(varName, "character"); 
  
  units = as(units, "character"); 
  ;ans = .Call('R_swig_CDMReader_getSliceVecInUnit__SWIG_0', self, varName, sb, units, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`CDMReader_getSliceVecInUnit__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`CDMReader_getSliceVecInUnit__SWIG_0`, "inputTypes") = c('_p_MetNoFimex__CDMReader', 'character', '_p_MetNoFimex__SliceBuilder', 'character')
class(`CDMReader_getSliceVecInUnit__SWIG_0`) = c("SWIGFunction", class('CDMReader_getSliceVecInUnit__SWIG_0'))

# Start of CDMReader_getSliceVecInUnit

`CDMReader_getSliceVecInUnit__SWIG_1` = function(self, varName, sb)
{
  varName = as(varName, "character"); 
  
  ;ans = .Call('R_swig_CDMReader_getSliceVecInUnit__SWIG_1', self, varName, sb, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`CDMReader_getSliceVecInUnit__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`CDMReader_getSliceVecInUnit__SWIG_1`, "inputTypes") = c('_p_MetNoFimex__CDMReader', 'character', '_p_MetNoFimex__SliceBuilder')
class(`CDMReader_getSliceVecInUnit__SWIG_1`) = c("SWIGFunction", class('CDMReader_getSliceVecInUnit__SWIG_1'))

`CDMReader_getSliceVecInUnit` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_MetNoFimex__CDMReader') && is.character(argv[[2]]) && extends(argtypes[3], '_p_MetNoFimex__SliceBuilder')) {
      f <- CDMReader_getSliceVecInUnit__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_MetNoFimex__CDMReader') && is.character(argv[[2]]) && extends(argtypes[3], '_p_MetNoFimex__SliceBuilder') && is.character(argv[[4]])) {
      f <- CDMReader_getSliceVecInUnit__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CDMReader_getSliceVecInUnit with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CDMReader

`delete_CDMReader` = function(self)
{
  ;.Call('R_swig_delete_CDMReader', self, PACKAGE='RFimex');
  
}

attr(`delete_CDMReader`, 'returnType') = 'void'
attr(`delete_CDMReader`, "inputTypes") = c('_p_MetNoFimex__CDMReader')
class(`delete_CDMReader`) = c("SWIGFunction", class('delete_CDMReader'))

# Start of accessor method for MetNoFimex::CDMReader
setMethod('$', '_p_MetNoFimex__CDMReader', function(x, name)

{
  accessorFuns = list('getCDM' = CDMReader_getCDM, 'getSliceVecInUnit' = CDMReader_getSliceVecInUnit);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for MetNoFimex::CDMReader
setMethod('delete', '_p_MetNoFimex__CDMReader', function(obj) {delete_MetNoFimex__CDMReader(obj)})
# Start of boost__shared_ptrCDMReader___deref__

`boost__shared_ptrCDMReader___deref__` = function(self)
{
  ;ans = .Call('R_swig_boost__shared_ptrCDMReader___deref__', self, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__CDMReader";
  
  ans
  
}

attr(`boost__shared_ptrCDMReader___deref__`, 'returnType') = '_p_MetNoFimex__CDMReader'
attr(`boost__shared_ptrCDMReader___deref__`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t')
class(`boost__shared_ptrCDMReader___deref__`) = c("SWIGFunction", class('boost__shared_ptrCDMReader___deref__'))

# Start of delete_boost__shared_ptrCDMReader

`delete_boost__shared_ptrCDMReader` = function(self)
{
  ;.Call('R_swig_delete_boost__shared_ptrCDMReader', self, PACKAGE='RFimex');
  
}

attr(`delete_boost__shared_ptrCDMReader`, 'returnType') = 'void'
attr(`delete_boost__shared_ptrCDMReader`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t')
class(`delete_boost__shared_ptrCDMReader`) = c("SWIGFunction", class('delete_boost__shared_ptrCDMReader'))

# Start of boost__shared_ptrCDMReader_getCDM

`boost__shared_ptrCDMReader_getCDM` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_boost__shared_ptrCDMReader_getCDM', self, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__CDM";
  
  ans
  
}

attr(`boost__shared_ptrCDMReader_getCDM`, 'returnType') = '_p_MetNoFimex__CDM'
attr(`boost__shared_ptrCDMReader_getCDM`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t')
class(`boost__shared_ptrCDMReader_getCDM`) = c("SWIGFunction", class('boost__shared_ptrCDMReader_getCDM'))

# Start of boost__shared_ptrCDMReader_getSliceVecInUnit

`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0` = function(self, varName, sb, units)
{
  varName = as(varName, "character"); 
  
  units = as(units, "character"); 
  ;ans = .Call('R_swig_boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0', self, varName, sb, units, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', 'character', '_p_MetNoFimex__SliceBuilder', 'character')
class(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0`) = c("SWIGFunction", class('boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0'))

# Start of boost__shared_ptrCDMReader_getSliceVecInUnit

`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1` = function(self, varName, sb)
{
  varName = as(varName, "character"); 
  
  ;ans = .Call('R_swig_boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1', self, varName, sb, PACKAGE='RFimex');
  class(ans) <- "_p_std__vectorT_double_std__allocatorT_double_t_t";
  
  ans
  
}

attr(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', 'character', '_p_MetNoFimex__SliceBuilder')
class(`boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1`) = c("SWIGFunction", class('boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1'))

`boost__shared_ptrCDMReader_getSliceVecInUnit` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_MetNoFimex__SliceBuilder')) {
      f <- boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t') && is.character(argv[[2]]) && extends(argtypes[3], '_p_MetNoFimex__SliceBuilder') && is.character(argv[[4]])) {
      f <- boost__shared_ptrCDMReader_getSliceVecInUnit__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for boost__shared_ptrCDMReader_getSliceVecInUnit with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for boost::shared_ptr<(MetNoFimex::CDMReader)>
setMethod('$', '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', function(x, name)

{
  accessorFuns = list('__deref__' = boost__shared_ptrCDMReader___deref__, 'getCDM' = boost__shared_ptrCDMReader_getCDM, 'getSliceVecInUnit' = boost__shared_ptrCDMReader_getSliceVecInUnit);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for boost::shared_ptr<(MetNoFimex::CDMReader)>
setMethod('delete', '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', function(obj) {delete_boost__shared_ptrT_MetNoFimex__CDMReader_t(obj)})
# Start of CDMFileReaderFactory_create

`CDMFileReaderFactory_create__SWIG_0` = function(fileType, filename, configFile, s_args, .copy = FALSE)
{
  fileType = as(fileType, "character"); 
  filename = as(filename, "character"); 
  configFile = as(configFile, "character"); 
  
  ;ans = .Call('R_swig_CDMFileReaderFactory_create__SWIG_0', fileType, filename, configFile, s_args, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_boost__shared_ptrT_MetNoFimex__CDMReader_t";
  
  ans
  
}

attr(`CDMFileReaderFactory_create__SWIG_0`, 'returnType') = '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t'
attr(`CDMFileReaderFactory_create__SWIG_0`, "inputTypes") = c('character', 'character', 'character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`CDMFileReaderFactory_create__SWIG_0`) = c("SWIGFunction", class('CDMFileReaderFactory_create__SWIG_0'))

# Start of CDMFileReaderFactory_create

`CDMFileReaderFactory_create__SWIG_1` = function(fileType, filename, configFile, .copy = FALSE)
{
  fileType = as(fileType, "character"); 
  filename = as(filename, "character"); 
  configFile = as(configFile, "character"); 
  ;ans = .Call('R_swig_CDMFileReaderFactory_create__SWIG_1', fileType, filename, configFile, as.logical(.copy), PACKAGE='RFimex');
  class(ans) <- "_p_boost__shared_ptrT_MetNoFimex__CDMReader_t";
  
  ans
  
}

attr(`CDMFileReaderFactory_create__SWIG_1`, 'returnType') = '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t'
attr(`CDMFileReaderFactory_create__SWIG_1`, "inputTypes") = c('character', 'character', 'character')
class(`CDMFileReaderFactory_create__SWIG_1`) = c("SWIGFunction", class('CDMFileReaderFactory_create__SWIG_1'))

`CDMFileReaderFactory_create` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if (is.character(argv[[1]]) && is.character(argv[[2]]) && is.character(argv[[3]])) {
      f <- CDMFileReaderFactory_create__SWIG_1; 
    }
  } else if (argc == 4) {
    if (is.character(argv[[1]]) && is.character(argv[[2]]) && is.character(argv[[3]]) && extends(argtypes[4], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')) {
      f <- CDMFileReaderFactory_create__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for CDMFileReaderFactory_create with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_CDMFileReaderFactory

`delete_CDMFileReaderFactory` = function(self)
{
  ;.Call('R_swig_delete_CDMFileReaderFactory', self, PACKAGE='RFimex');
  
}

attr(`delete_CDMFileReaderFactory`, 'returnType') = 'void'
attr(`delete_CDMFileReaderFactory`, "inputTypes") = c('_p_MetNoFimex__CDMFileReaderFactory')
class(`delete_CDMFileReaderFactory`) = c("SWIGFunction", class('delete_CDMFileReaderFactory'))

setMethod('delete', '_p_MetNoFimex__CDMFileReaderFactory', function(obj) {delete_MetNoFimex__CDMFileReaderFactory(obj)})
# Start of new_NetCDF_CDMWriter

`NetCDF_CDMWriter__SWIG_0` = function(reader, filename, configFile, version)
{
  filename = as(filename, "character"); 
  configFile = as(configFile, "character"); 
  version = as.integer(version); 
  
  if(length(version) > 1) {
    warning("using only the first element of version");
  };
  
  ;ans = .Call('R_swig_new_NetCDF_CDMWriter__SWIG_0', reader, filename, configFile, version, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__NetCDF_CDMWriter";
  
  reg.finalizer(ans, delete_NetCDF_CDMWriter)
  ans
  
}

attr(`NetCDF_CDMWriter__SWIG_0`, 'returnType') = '_p_MetNoFimex__NetCDF_CDMWriter'
attr(`NetCDF_CDMWriter__SWIG_0`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', 'character', 'character', 'integer')
class(`NetCDF_CDMWriter__SWIG_0`) = c("SWIGFunction", class('NetCDF_CDMWriter__SWIG_0'))

# Start of new_NetCDF_CDMWriter

`NetCDF_CDMWriter__SWIG_1` = function(reader, filename, configFile)
{
  filename = as(filename, "character"); 
  configFile = as(configFile, "character"); 
  ;ans = .Call('R_swig_new_NetCDF_CDMWriter__SWIG_1', reader, filename, configFile, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__NetCDF_CDMWriter";
  
  reg.finalizer(ans, delete_NetCDF_CDMWriter)
  ans
  
}

attr(`NetCDF_CDMWriter__SWIG_1`, 'returnType') = '_p_MetNoFimex__NetCDF_CDMWriter'
attr(`NetCDF_CDMWriter__SWIG_1`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', 'character', 'character')
class(`NetCDF_CDMWriter__SWIG_1`) = c("SWIGFunction", class('NetCDF_CDMWriter__SWIG_1'))

# Start of new_NetCDF_CDMWriter

`NetCDF_CDMWriter__SWIG_2` = function(reader, filename)
{
  filename = as(filename, "character"); 
  ;ans = .Call('R_swig_new_NetCDF_CDMWriter__SWIG_2', reader, filename, PACKAGE='RFimex');
  class(ans) <- "_p_MetNoFimex__NetCDF_CDMWriter";
  
  reg.finalizer(ans, delete_NetCDF_CDMWriter)
  ans
  
}

attr(`NetCDF_CDMWriter__SWIG_2`, 'returnType') = '_p_MetNoFimex__NetCDF_CDMWriter'
attr(`NetCDF_CDMWriter__SWIG_2`, "inputTypes") = c('_p_boost__shared_ptrT_MetNoFimex__CDMReader_t', 'character')
class(`NetCDF_CDMWriter__SWIG_2`) = c("SWIGFunction", class('NetCDF_CDMWriter__SWIG_2'))

`NetCDF_CDMWriter` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t') && is.character(argv[[2]])) {
      f <- NetCDF_CDMWriter__SWIG_2; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t') && is.character(argv[[2]]) && is.character(argv[[3]])) {
      f <- NetCDF_CDMWriter__SWIG_1; 
    }
  } else if (argc == 4) {
    if (extends(argtypes[1], '_p_boost__shared_ptrT_MetNoFimex__CDMReader_t') && is.character(argv[[2]]) && is.character(argv[[3]]) && (is.integer(argv[[4]]) || is.numeric(argv[[4]]))) {
      f <- NetCDF_CDMWriter__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for NetCDF_CDMWriter with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_NetCDF_CDMWriter

`delete_NetCDF_CDMWriter` = function(self)
{
  ;.Call('R_swig_delete_NetCDF_CDMWriter', self, PACKAGE='RFimex');
  
}

attr(`delete_NetCDF_CDMWriter`, 'returnType') = 'void'
attr(`delete_NetCDF_CDMWriter`, "inputTypes") = c('_p_MetNoFimex__NetCDF_CDMWriter')
class(`delete_NetCDF_CDMWriter`) = c("SWIGFunction", class('delete_NetCDF_CDMWriter'))

setMethod('delete', '_p_MetNoFimex__NetCDF_CDMWriter', function(obj) {delete_MetNoFimex__NetCDF_CDMWriter(obj)})

